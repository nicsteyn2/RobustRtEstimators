<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Other methods – Robust Rt estimation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Robust Rt estimation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./EpiEstim.html"> 
<span class="menu-text">EpiEstim in Julia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./EpiFilter.html"> 
<span class="menu-text">EpiFilter in Julia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./OtherMethods.html" aria-current="page"> 
<span class="menu-text">Other methods</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/nicsteyn2/RobustRtEstimators" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#executive-summary" id="toc-executive-summary" class="nav-link active" data-scroll-target="#executive-summary">Executive summary</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#filtering-versus-smoothing" id="toc-filtering-versus-smoothing" class="nav-link" data-scroll-target="#filtering-versus-smoothing">Filtering versus smoothing</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#epifilter-smoothing-version" id="toc-epifilter-smoothing-version" class="nav-link" data-scroll-target="#epifilter-smoothing-version">EpiFilter (smoothing version)</a></li>
  <li><a href="#epinow2" id="toc-epinow2" class="nav-link" data-scroll-target="#epinow2">EpiNow2</a></li>
  <li><a href="#epilps-map" id="toc-epilps-map" class="nav-link" data-scroll-target="#epilps-map">EpiLPS (MAP)</a></li>
  <li><a href="#epilps-mala" id="toc-epilps-mala" class="nav-link" data-scroll-target="#epilps-mala">EpiLPS (MALA)</a></li>
  <li><a href="#rtestim" id="toc-rtestim" class="nav-link" data-scroll-target="#rtestim">rtestim</a></li>
  <li><a href="#additional-methodological-notes" id="toc-additional-methodological-notes" class="nav-link" data-scroll-target="#additional-methodological-notes">Additional methodological notes</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#prior-distributions-on-smoothing-parameters" id="toc-prior-distributions-on-smoothing-parameters" class="nav-link" data-scroll-target="#prior-distributions-on-smoothing-parameters">Prior distributions on smoothing parameters</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Other methods</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>During work for <em><a href="https://doi.org/10.1093/aje/kwaf165">Robust uncertainty quantification…</a></em>, we considered other methods. These were not included in the main text as they are retrospective rather than real-time (although they can be used for real-time analysis also). Preliminary results are included here.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>We view this page as a living document. We have largely stuck to default options when implementing the various methods. If you think something can be improved, or you think something important is missing, please <a href="mailto:nicholas.steyn@univ.ox.ac.uk">get in contact</a>!</p>
</div>
</div>
<section id="executive-summary" class="level3">
<h3 class="anchored" data-anchor-id="executive-summary">Executive summary</h3>
<ul>
<li>We present and implement novel methods for evaluating existing models on <strong>observable data</strong> (calibration and CRPS of reported cases).</li>
<li>EpiFilter (smoothing) generally performs the best, although this is partially due to matching assumptions about observation noise.</li>
<li>The uniform/flat prior distribution used for EpiFilter’s smoothing parameter has a useful property: it ensures the MAP value is equal to the MLE. The predictive decomposition of the likelihood then ensures this is also the value that optimises one-step-ahead predictions. That is, using a flat prior distribution enforces a MAP that is optimal for one-step-ahead forecasting.</li>
<li>EpiLPS(MALA) outperforms EpiLPS(MAP), most likely due to the proper handling of uncertainty in smoothing parameters. This supports our argument in <em><a href="https://doi.org/10.1093/aje/kwaf165">Robust uncertainty quantification…</a></em> that parameters should be marginalised out rather than fixed at some optimal value.</li>
</ul>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<p>Many state-of-the-art <span class="math inline">\(R_t\)</span> estimation methods target the smoothing distribution, rather than the filtering distribution (see below). Examples include the smoothing version of EpiFilter <span class="citation" data-cites="paragImprovedEstimationTimevarying2021">(<a href="#ref-paragImprovedEstimationTimevarying2021" role="doc-biblioref">Parag 2021</a>)</span>, EpiNow2 <span class="citation" data-cites="abbottEstimatingTimevaryingReproduction2020">(<a href="#ref-abbottEstimatingTimevaryingReproduction2020" role="doc-biblioref">Abbott et al. 2020</a>)</span>, EpiLPS <span class="citation" data-cites="gressaniEpiLPSFastFlexible2022">(<a href="#ref-gressaniEpiLPSFastFlexible2022" role="doc-biblioref">Gressani et al. 2022</a>)</span>, and rtestim <span class="citation" data-cites="liuRtestimTimevaryingReproduction2024">(<a href="#ref-liuRtestimTimevaryingReproduction2024" role="doc-biblioref">Liu et al. 2024</a>)</span>. We compare and contrast these methods on simulated data here.</p>
<p>For each method, we:</p>
<ul>
<li>Find the posterior distribution for <span class="math inline">\(R_t\)</span></li>
<li>Find the posterior “predictive” distribution for observed cases <span class="math inline">\(\tilde{C}_t\)</span></li>
<li>Calculate the calibration of the implied 95% credible intervals for both <span class="math inline">\(R_t\)</span> and <span class="math inline">\(C_t\)</span></li>
<li>Calculate the CRPS of the posterior predictive distribution for <span class="math inline">\(C_t\)</span></li>
</ul>
<p>We use <span class="math inline">\(\tilde{C}_t\)</span> to highlight when we are treating reported cases as a random variable, instead of as observed data.</p>
<p>Unlike the other methods listed, rtestim is frequentist in nature. In this case, we replace posterior means/modes and credible intervals with estimates and confidence intervals. All of the above metrics still apply and carry comparable interpretations.</p>
<p>The posterior predictive distribution obtained from smoothing methods typically provides within-sample estimates. That is, the observed value <span class="math inline">\(C_t\)</span> is used to find the posterior predictive distribution of <span class="math inline">\(\tilde{C}_t\)</span>. This can occur either indirectly (observed <span class="math inline">\(C_t\)</span> informs <span class="math inline">\(R_t\)</span> estimates, which then are used to predict <span class="math inline">\(\tilde{C}_t\)</span>) or directly (observed <span class="math inline">\(C_t\)</span> informs estimates of latent infection incidence, from which <span class="math inline">\(\tilde{C}_t\)</span> are generated). <strong>This changes the interpretation of CRPS from a score of future predictions to a score of how well the data-generating mechanism is modelled.</strong></p>
<p>In many cases, existing methodology had to be extended to find the posterior predictive distributions or to calculate the CRPS. Model descriptions are otherwise kept to a minimum. Where possible, default options of these models are used, although minor modifications are made where defaults lead to obviously suboptimal results.</p>
<p>Code to explicitly reproduce these results and figures is provided <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods">on GitHub</a>.</p>
<section id="filtering-versus-smoothing" class="level3">
<h3 class="anchored" data-anchor-id="filtering-versus-smoothing">Filtering versus smoothing</h3>
<p>The <strong>filtering posterior distribution</strong> depends only on past data and is written <span class="math inline">\(P(R_t | C_{1:t})\)</span>, whereas the <strong>smoothing posterior distribution</strong> depends on all data and is written <span class="math inline">\(P(R_t | C_{1:T})\)</span> <span class="citation" data-cites="sarkkaBayesianFilteringSmoothing2013">(<a href="#ref-sarkkaBayesianFilteringSmoothing2013" role="doc-biblioref">Särkkä 2013</a>)</span>.</p>
<p>When producing estimates at the most recent time-step, only the filtering distribution is accessible, as future data are not yet available, whereas the smoothing distribution is generally preferred for retrospective analysis, as it incorporates all available data. Note that, at time <span class="math inline">\(t = T\)</span>, the filtering and smoothing distributions are equivalent.</p>
<p>In <em><a href="https://doi.org/10.1093/aje/kwaf165">Robust uncertainty quantification in popular estimators of the instantaneous reproduction number</a></em>, we focus on methods for estimating <span class="math inline">\(R_t\)</span> in real-time. That is, we target the <em>filtering distribution</em> rather than the <em>smoothing distribution</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Here we consider the latter.</p>
</section>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="epifilter-smoothing-version" class="level2">
<h2 class="anchored" data-anchor-id="epifilter-smoothing-version">EpiFilter (smoothing version)</h2>
<p>In addition to the filtering distribution, EpiFilter also provides a method to find the smoothing distribution, conditional on smoothing parameter <span class="math inline">\(\eta\)</span>. Using the same arguments as for filtering, we marginalise over <span class="math inline">\(\eta\)</span> to find the marginal smoothing distribution:</p>
<p><span class="math display">\[ P(R_t|C_{1:T}) = \int P(R_t | C_{1:T}, \eta) P(\eta | C_{1:T}) \ d\eta \]</span></p>
<p>This requires the posterior distribution for <span class="math inline">\(\eta\)</span> once all data are collected: <span class="math inline">\(P(\eta|C_{1:T})\)</span>. We introduce methodology for this in <em><a href="https://doi.org/10.1093/aje/kwaf165">Robust uncertainty quantification…</a></em>.</p>
<p>The posterior smoothing distribution for observed case incidence is found by marginalising over <span class="math inline">\(R_t\)</span> from the smoothing posterior distribution for <span class="math inline">\(R_t\)</span> (instead of the predictive distribution for <span class="math inline">\(R_t\)</span>):</p>
<p><span class="math display">\[ P(\tilde{C}_t | C_{1:T}) = \int P(\tilde{C}_t | R_t, C_{1:T}) P(R_t | C_{1:T}) \ dR_t \]</span></p>
<p>For simplicity, we use the renewal model for <span class="math inline">\(P(\tilde{C}_t | R_t, C_{1:T})\)</span>, even though this ignores future reported case incidence. That is, future case data <span class="math inline">\(C_{t:T}\)</span> only features in <span class="math inline">\(P(\tilde{C}_t | C_{1:T})\)</span> via <span class="math inline">\(R_t\)</span>.</p>
<p>CRPS is calculated using the methodology outlined in <em><a href="https://doi.org/10.1093/aje/kwaf165">Robust uncertainty quantification…</a></em>.</p>
</section>
<section id="epinow2" class="level2">
<h2 class="anchored" data-anchor-id="epinow2">EpiNow2</h2>
<p>Rather than using a Gaussian random walk (as in EpiFilter) or fixed sliding windows (as in EpiEstim), EpiNow2 models the evolution of <span class="math inline">\(R_t\)</span> using a Gaussian process. The default implementation then assumes that latent infection incidence follows a deterministic renewal model. Reported cases are assumed to be negative binomially distributed around the true infection, with a day-of-the-week effect that is estimated during the fitting process. That is, EpiNow2 accounts for both process noise (in the evolution of <span class="math inline">\(R_t\)</span>) and observation noise (in the distribution for reported cases).</p>
<p>Smoothness in <span class="math inline">\(R_t\)</span> is primarily controlled by the Gaussian process kernel (default Matern 3/2, with lengthscale <span class="math inline">\(\ell\)</span> and magnitude <span class="math inline">\(\alpha\)</span>). In particular, prior assumptions about the lengthscale <span class="math inline">\(\ell\)</span> have a significant impact on the smoothness of resulting estimates. It is also expected that prior assumptions about the observation overdispersion will have a secondary effect on the smoothness of <span class="math inline">\(R_t\)</span> estimates (as this impacts the trade-off between process and observation noise).</p>
<p>The EpiNow2 package provides pre-built functionality to extract central estimates and credible intervals for <span class="math inline">\(R_t\)</span> and observed cases. As far as we are aware, the package does not provide a method to calculate the CRPS, so we provide our own sample-based implementation.</p>
<p>Samples from the posterior distribution for reported cases <span class="math inline">\(\{x_t^{(i)}\}_{i=1}^N\)</span> at time <span class="math inline">\(t\)</span> are extracted from the Stan fit object. We then use the sample-based CRPS estimator:</p>
<p><span class="math display">\[ \text{CRPS}_t = \frac{1}{N} \sum_{i=1}^n |x_t^{(i)} - C_t| - \frac{1}{2N^2} \sum_{i=1}^n \sum_{j=1}^n |x_t^{(i)} - x_t^{(j)}| \]</span></p>
<p>Calculating this for each time-step <span class="math inline">\(t\)</span> and taking the average gives the CRPS for observed case incidence. Code to reproduce this is available <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods/EpiNow2">on GitHub</a>.</p>
<p>By default, EpiNow2 uses a log normal prior distribution for the lengthscale <span class="math inline">\(\ell\)</span> with mean 21 days and standard deviation 7 days. We also test an alternative and less informative inverse-gamma prior distribution provided with the package, which performs considerably better.</p>
</section>
<section id="epilps-map" class="level2">
<h2 class="anchored" data-anchor-id="epilps-map">EpiLPS (MAP)</h2>
<p>EpiLPS models latent infection incidence using Bayesian P-splines. Given infection incidence <span class="math inline">\(\mu(t)\)</span> and overdispersion parameter <span class="math inline">\(\rho\)</span>, reported cases are assumed to be negative binomially distributed around <span class="math inline">\(\mu(t)\)</span>. In the maximum a posteriori (MAP) version of EpiLPS, central estimates of <span class="math inline">\(R_t\)</span> are calculated using a plug-in estimate of the posterior mean incidence <span class="math inline">\(\hat{\mu}(t)\)</span> and uncertainty is derived using a delta method. Like EpiNow2, EpiLPS explicitly accounts for both process noise (in the splines used to model infection incidence) and observation noise (in the distribution for reported cases).</p>
<p>Smoothness in <span class="math inline">\(R_t\)</span> is primarily controlled by parameter <span class="math inline">\(\lambda\)</span>, where larger values penalise sharp changes in infection incidence. A hierarchical prior distribution is assumed for <span class="math inline">\(\lambda\)</span>. Prior assumptions about the overdispersion parameter <span class="math inline">\(\rho\)</span> also likely impact the smoothness of <span class="math inline">\(R_t\)</span> estimates, as this controls how much noise is associated with the observation process rather than the underlying epidemic process. The MAP version of EpiLPS selects optimal values of <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\rho\)</span> using an optimization routine.</p>
<p>While <span class="math inline">\(K = 30\)</span> is used as the default number of splines, we find that this leads to inaccurate inference on our example datasets. For our examples, we increase this to <span class="math inline">\(K = 100\)</span>, which allows for more flexible inference.</p>
<p>We provide two extensions to the EpiLPS package:</p>
<ol type="1">
<li>Methods to sample from the posterior distribution for reported cases.</li>
<li>A CRPS estimator for the posterior distribution for reported cases.</li>
</ol>
<p>Infection incidence is defined as <span class="math inline">\(\mu(t) = \exp(\theta^T b(t))\)</span>, where <span class="math inline">\(\theta\)</span> is an estimated vector of spline coefficients and <span class="math inline">\(b(t)\)</span> are the basis functions evaluated at time <span class="math inline">\(t\)</span>. The MAP version of EpiLPS uses a multivariate Gaussian approximation to <span class="math inline">\(\theta\)</span> at the MAP estimate of <span class="math inline">\(\lambda\)</span>. We sample from this distribution:</p>
<p><span class="math display">\[ \theta^{(i)} \sim MVN(\hat{\theta}, Q_\lambda^{-1}) \]</span></p>
<p>and use these samples to generate samples of latent infection incidence:</p>
<p><span class="math display">\[ \mu^{(i)}(t) = \exp(\theta^{(i)T} b(t)) \]</span></p>
<p>from which samples of observed data are generated:</p>
<p><span class="math display">\[ C_t^{(i)} \sim \text{NegBin}(\mu^{(i)}(t), \rho) \]</span></p>
<p>where <span class="math inline">\(\rho\)</span> is the MAP value of the overdispersion parameter. This is repeated <span class="math inline">\(N\)</span> times (default <span class="math inline">\(N = 1000\)</span>) at each value of <span class="math inline">\(t\)</span>. The mean of these <span class="math inline">\(N\)</span> samples is reported as the central estimate, with 95% credible intervals obtained by taking the 2.5th and 97.5th percentile values.</p>
<p>The CRPS is calculated similarly, first by sampling <span class="math inline">\(\mu^{(i)}(t)\)</span> as above and then using the <em>crps_nbinom()</em> function from the <em>scoringRules</em> package in R to calculate the CRPS value for each sampled <span class="math inline">\(\mu^{(i)}(t)\)</span> and <span class="math inline">\(C_t\)</span>. The mean of these <span class="math inline">\(N\)</span> CRPS values is reported as the CRPS for the <span class="math inline">\(t^{th}\)</span> observed case incidence.</p>
<p>Some code is available <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods/EpiLPSMAP">on GitHub</a>, although copyright limitations prevent us from providing the full implementation, in which case we outline the steps required to reproduce our analysis.</p>
</section>
<section id="epilps-mala" class="level2">
<h2 class="anchored" data-anchor-id="epilps-mala">EpiLPS (MALA)</h2>
<p>The MALA version of EpiLPS replaces the Laplace approximation and optimisation routine with a full MCMC-type sampler. This has the advantage of returning a posterior distribution on <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\rho\)</span>, as well as properly marginalising out uncertainty about these quantities. As the true posterior distribution of spline coefficients <span class="math inline">\(\theta\)</span> is targeted, we also expect the posterior distributions for <span class="math inline">\(R_t\)</span> and observed cases incidence to be more accurate. This comes at a cost of slightly increased computational complexity, although we do not find this to be prohibitive.</p>
<p>The default version of EpiLPS(MALA) does not return the MCMC sampling object. In order to access this, we created a customised version of <em>estimRmcmc.R</em> that includes <em>MCMC=MCMCout</em> in the outputlist of the function. This is the sole change required to this script, although running it requires having local copies of some files from the EpiLPS package. A list of the required files is given <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods/EpiLPSMALA">here</a>.</p>
<p>We make the same two extensions to EpiLPS(MALA) as we did to EpiLPS(MAP):</p>
<ol type="1">
<li>Methods to sample from the posterior distribution for reported cases.</li>
<li>A CRPS estimator for the posterior distribution for reported cases.</li>
</ol>
<p>Samples of reported case incidence are extracted from the MCMC sampling object. For each sample <span class="math inline">\(i  = 1, \ldots, N\)</span> and time-step <span class="math inline">\(t = 1, \ldots, T\)</span> we sample:</p>
<p><span class="math display">\[ C_t^{(i)} \sim \text{NegBin}(\exp(\theta^{(i)T} b(t)), \rho^{(i)}) \]</span></p>
<p>where <span class="math inline">\(\theta^{(i)}\)</span> and <span class="math inline">\(\rho^{(i)}\)</span> are samples from the MCMC sampling object. Note the use of <span class="math inline">\(\rho^{(i)}\)</span> instead of the MAP value of <span class="math inline">\(\rho\)</span>, ensuring we are appropriately accounting for uncertainty in this parameter.</p>
<p>The CRPS is calculated from sampled <span class="math inline">\(C_t^{(i)}\)</span> using the same approach as for EpiNow2, relying upon the sample-based CRPS estimator (see above).</p>
<p>Some code is available <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods/EpiLPSMALA">on GitHub</a>, although copyright limitations prevent us from providing the full implementation, in which case we outline the steps required to reproduce our analysis.</p>
</section>
<section id="rtestim" class="level2">
<h2 class="anchored" data-anchor-id="rtestim">rtestim</h2>
<p>In contrast to the aforementioned Bayesian methods, rtestim is grounded in a frequentist framework. <span class="math inline">\(R_t\)</span> is modelled using piecewise cubic functions with <span class="math inline">\(\ell_1\)</span> regularisation on the divided differences. This regularisation enforces sparsity in changes in <span class="math inline">\(R_t\)</span>, allowing for locally adaptive smoothness, a key advantage over the other methods considered here that assume global smoothness.</p>
<p>A tuning parameter <span class="math inline">\(\lambda\)</span> controls the strength of this regularisation, with larger values enforcing smoother estimates of <span class="math inline">\(R_t\)</span>. The optimal value of this parameter is automatically chosen by rtestim using cross-validation.</p>
<p>rtestim uses the delta method to calculate confidence intervals. Built-in functions are provided to calculate these for <span class="math inline">\(R_t\)</span> and observed case incidence, for any user-specified significance level. To match the other methods we use a 95% confidence level.</p>
<p>While the frequentist framework of rtestim does not admit a posterior distribution for observed case incidence, we can still use CRPS to measure how well the confidence intervals approximate the observed distribution of the data. To do this, we treat the bounds of the confidence intervals at different significance levels as defining quantiles of an empirical CDF. That is, at each time-step <span class="math inline">\(t\)</span>, we find <span class="math inline">\(x_t^{(i)}\)</span> such that <span class="math inline">\(q^{(i)} = F(x_i^{(t)})\)</span> for <span class="math inline">\(q^{(i)} = 0.01, 0.02, \ldots, 0.99\)</span>. We then approximate the CRPS numerically at time-step <span class="math inline">\(t\)</span> using the trapezoidal rule:</p>
<p><span class="math display">\[ CRPS_t = \sum_{i=1}^{n-1} \frac{1}{2} \left(x_t^{(i+1)} - x_t^{(i)}\right) \left[ \left(q^{(i+1)} - \mathbb{I}(x_t^{(i+1)} \geq y_t)\right)^2 + \left(q^{(i)} - \mathbb{I}(x_t^{(i)} \geq y_t)\right)^2 \right] \]</span></p>
<p>Averaging <span class="math inline">\(CRPS_t\)</span> over all time-steps <span class="math inline">\(t\)</span> gives the CRPS for observed case incidence. Code to reproduce this is available <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods/rtestim">on GitHub</a>.</p>
</section>
<section id="additional-methodological-notes" class="level2">
<h2 class="anchored" data-anchor-id="additional-methodological-notes">Additional methodological notes</h2>
<p>Each method handles the wind-in period differently, particularly when <span class="math inline">\(t\)</span> is small compared to generation times. This can become fairly complicated, and is not the point of this supplementary section. When estimating or calculating coverage and CRPS, we use time-steps <span class="math inline">\(t = 10, \ldots, T\)</span> to avoid differences from this period impacting our results.</p>
<p>Posterior parameter values were calculated using a grid-based approach for EpiFilter. For EpiLPS (MALA) and EpiNow2, a sampling approach was required. The mean, 2.5th and 97.5th quantiles of these samples were calculated to estimate the posterior mean and 95% credible intervals. Posterior mode values were calculated using a kernel density estimate from the default <em>density()</em> function in R.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>Theoretical links between Gaussian random walks, Gaussian processes, splines, and piecewise polynomials, as well as the fact that all models use the same underlying renewal model for the epidemic process, suggest that the methods should perform similarly in practice. However, we find this not to be the case.</p>
<p><a href="#tbl-scores" class="quarto-xref">Table&nbsp;1</a> presents the coverage of <span class="math inline">\(R_t\)</span> and reported cases, as well as the CRPS for reported cases for each method on each of the three simulations considered in the main text. <a href="#fig-results" class="quarto-xref">Figure&nbsp;1</a> presents the corresponding estimates. While the methods produce mostly well-calibrated 95% uncertainty intervals for observed case data, coverage of <span class="math inline">\(R_t\)</span> estimates varies significantly, as does the CRPS for observed case incidence.</p>
<div id="tbl-scores" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-scores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Coverage of 95% credible intervals (confidence intervals for rtestim) for <span class="math inline">\(R_t\)</span> and reported cases, and CRPS for reported cases, for each method on each simulation.
</figcaption>
<div aria-describedby="tbl-scores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="resources/scores.png" class="img-fluid figure-img" width="400">
</div>
</figure>
</div>
<div id="fig-results" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="resources/othermethods.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Estimates of <span class="math inline">\(R_t\)</span> and observed case incidence for each method on each simulation.
</figcaption>
</figure>
</div>
<p>The smoothed version of EpiFilter consistently outperforms (i.e.&nbsp;exhibits coverage of 95% credible intervals closest to 95%, and the lowest CRPS values) the other methods on these simulated datasets. This is expected in the random walk simulation, where the dynamic model employed by EpiFilter matches the simulated data. The better performance of EpiFilter on the other simulations is likely explained by two factors: (1) EpiFilter does not account for observation noise (which is absent in the simulated data), and (2) the flat prior distribution on <span class="math inline">\(\eta\)</span> is less informative than the default prior distributions used by other methods. These are both testable hypotheses that could be explored in future work to better understand the trade-offs between smoothing, model assumptions, and robustness of performance.</p>
<p>EpiLPS and EpiNow2 both assume that reported case incidence are negative binomially-distributed about some smooth true infection incidence (upon which the renewal model is placed), thus explicitly modelling observation noise. Process noise is derived from either the smoothness of the splines (EpiLPS) or the Gaussian process (EpiNow2). While the overdispersion parameter is estimated in both methods, the negative binomial distribution implies a lower bound of Poisson observation noise. In the simulated data, however, all noise is assumed to arise from the underlying process. By enforcing the inclusion of observation noise, EpiLPS and EpiNow2 underestimate process noise, and thus produce overly smooth estimates of <span class="math inline">\(R_t\)</span>. This is likely to be less impactful on real-world datasets, where observation noise is typically a significant factor.</p>
<p>It is possible to use CRPS as model selection criterion instead of cross-validation. Early code to do this is provided <a href="https://github.com/nicsteyn2/RobustRtEstimators/tree/main/othermethods/rtestim">on GitHub</a>.</p>
<p>The MALA version of EpiLPS outperforms the MAP version. This is unsurprising given that, in the MALA version, uncertainty associated with <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\rho\)</span> is fully marginalised out, whereas the MAP version selects optimal point estimates of these parameters. This lends support to the argument in the main paper for the marginalisation of these parameters over selection. The MALA version also targets the true posterior distribution for <span class="math inline">\(\mu(t)\)</span>, whereas the MAP version uses a Laplace approximation, which is particularly advantageous when comparing CRPS values.</p>
<p><a href="#fig-results" class="quarto-xref">Figure&nbsp;1</a> also highlights critical oversmoothing in default EpiNow2 on the sinusoidal simulation. The posterior distribution for lengthscale <span class="math inline">\(\ell\)</span> is bi-modal, with one mode at a small value of <span class="math inline">\(\ell\)</span> (where the model follows the data) and another mode at a larger value of <span class="math inline">\(\ell\)</span>, where the model estimates flat incidence with large reporting noise accounting for changes in observed cases.</p>
<section id="prior-distributions-on-smoothing-parameters" class="level2">
<h2 class="anchored" data-anchor-id="prior-distributions-on-smoothing-parameters">Prior distributions on smoothing parameters</h2>
<p>While all methods listed estimate smoothing parameter(s) from the data, they handle this in different ways. Our implementation of EpiFilter, EpiNow2, and EpiLPS(MALA) marginalise this parameter out. EpiLPS(MAP) and rtestim select optimal point values of this parameter.</p>
<p>Of particular note is EpiNow2’s prior on lengthscale <span class="math inline">\(\ell\)</span>. Prior and posterior modes and credible intervals are give in <a href="#tbl-priorposterior" class="quarto-xref">Table&nbsp;2</a>. The default log-normal prior distribution often leads to oversmoothing, with an extreme example being the bimodal posterior on the sinusoidal simulation - where one mode implies that <span class="math inline">\(R_t\)</span> is (nearly) fixed, and all variation in reported cases is assigned to the observation process.</p>
<div id="tbl-priorposterior" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-priorposterior-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: MAP and 95% credible intervals for the parameter prior and posterior distributions, where they exist. The upper portion of the table refers to smoothing parameters and the lower portion refers to estimated overdispersion. Numerical instabilities lead to large variations in statistics in some cases which are marked by a “-”. As rtestim is frequentist, there are no prior assumptions on <span class="math inline">\(\lambda\)</span>, and the values are chosen by cross-validation instead of being MAP estimates.
</figcaption>
<div aria-describedby="tbl-priorposterior-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="resources/priorposteriors.png" class="img-fluid figure-img">
</div>
</figure>
</div>
<p>By default, we place a uniform prior distribution on EpiFilter’s <span class="math inline">\(\eta\)</span> parameter. While we avoid claiming that the uniform prior distribution is uninformative, we do highlight a key advantage of this: the MAP is equal to the MLE. By the predictive decomposition of the likelihood, this is also the value of <span class="math inline">\(\eta\)</span> that optimises one-step-ahead predictions. That is, using a flat prior distribution enforces a MAP that is optimal for one-step-ahead forecasting. Furthermore, if the model is correctly specified, this implies that the MAP is optimal for any n-step-ahead forecast.</p>
</section>
</section>
<section id="references" class="level1">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-abbottEstimatingTimevaryingReproduction2020" class="csl-entry" role="listitem">
Abbott, Sam, Joel Hellewell, Robin N. Thompson, Katharine Sherratt, Hamish P. Gibbs, Nikos I. Bosse, James D. Munday, et al. 2020. <span>“Estimating the Time-Varying Reproduction Number of <span>SARS-CoV-2</span> Using National and Subnational Case Counts.”</span> <em>Wellcome Open Research</em> 5 (December): 112. <a href="https://doi.org/10.12688/wellcomeopenres.16006.2">https://doi.org/10.12688/wellcomeopenres.16006.2</a>.
</div>
<div id="ref-gressaniEpiLPSFastFlexible2022" class="csl-entry" role="listitem">
Gressani, Oswaldo, Jacco Wallinga, Christian L. Althaus, Niel Hens, and Christel Faes. 2022. <span>“<span>EpiLPS</span>: <span>A</span> Fast and Flexible <span>Bayesian</span> Tool for Estimation of the Time-Varying Reproduction Number.”</span> <em>PLOS Computational Biology</em> 18 (10): e1010618. <a href="https://doi.org/10.1371/journal.pcbi.1010618">https://doi.org/10.1371/journal.pcbi.1010618</a>.
</div>
<div id="ref-liuRtestimTimevaryingReproduction2024" class="csl-entry" role="listitem">
Liu, Jiaping, Zhenglun Cai, Paul Gustafson, and Daniel J. McDonald. 2024. <span>“Rtestim: <span class="nocase">Time-varying</span> Reproduction Number Estimation with Trend Filtering.”</span> <em>PLOS Computational Biology</em> 20 (8): e1012324. <a href="https://doi.org/10.1371/journal.pcbi.1012324">https://doi.org/10.1371/journal.pcbi.1012324</a>.
</div>
<div id="ref-paragImprovedEstimationTimevarying2021" class="csl-entry" role="listitem">
Parag, Kris V. 2021. <span>“Improved Estimation of Time-Varying Reproduction Numbers at Low Case Incidence and Between Epidemic Waves.”</span> <em>PLOS Computational Biology</em> 17 (9): e1009347. <a href="https://doi.org/10.1371/journal.pcbi.1009347">https://doi.org/10.1371/journal.pcbi.1009347</a>.
</div>
<div id="ref-sarkkaBayesianFilteringSmoothing2013" class="csl-entry" role="listitem">
Särkkä, Simo. 2013. <em>Bayesian <span>Filtering</span> and <span>Smoothing</span></em>. 1st ed. Cambridge University Press. <a href="https://doi.org/10.1017/CBO9781139344203">https://doi.org/10.1017/CBO9781139344203</a>.
</div>
</div>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The “smoothing” in “smoothing distribution” has a different meaning to “smoothing” in “smoothing parameter”.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2024, Nicholas Steyn nicholas.steyn@univ.ox.ac.uk</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>